---
/**
 * Notes index page
 *
 * Lists only notes that are promoted to the 'notes' surface.
 * Nested-only notes (those without surfaces or with different surfaces) do not appear.
 */
import NavBreadcrumb from '~/components/nav-breadcrumb.astro';
import BaseHead from '~/components/base-head.astro';
import { defaultMeta } from '~/config/site';
import RootLayout from '~/layouts/root-layout.astro';
import NoteCard from '~/components/note-card.astro';
import { filterAndSortContent } from '~/utils/content-operations';
import MobileTagsFilter from '~/components/mobile-tags-filter.astro';
import { buildNoteManifest, validateManifest } from '~/lib/notes/manifest';
import type { NoteEntry } from '~/lib/notes/types';
import type { ObsidianNote } from '~/utils/get-obsidian-notes';
import { isDevEnv } from '~/utils/is-dev-env';

// Build manifest and get promoted notes
const manifest = await buildNoteManifest();
validateManifest(manifest);

// Logic for showing notes on index:
// 1. Flat files (notes/*.md) → always show (canonical route has no slashes)
// 2. Nested files (notes/DDIA/*.md) → only show if surfaces includes 'notes'
const promotedEntries = manifest.entries.filter((entry) => {
  const isFlat = !entry.canonicalRoute.includes('/');
  const isPromotedSurface = entry.frontmatter.surfaces?.includes('notes');
  return isFlat || isPromotedSurface;
});

// Helper function to validate dates
function getValidDate(
  dateValue: string | Date | undefined,
): string | undefined {
  if (!dateValue) return undefined;
  const dateStr =
    typeof dateValue === 'string' ? dateValue : dateValue.toISOString();
  if (dateStr.startsWith('0002-') || dateStr.length < 8) {
    return undefined;
  }
  try {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      return undefined;
    }
    return date.toISOString();
  } catch {
    return undefined;
  }
}

// Convert manifest entries to ObsidianNote format for NoteCard
function toObsidianNote(entry: NoteEntry): ObsidianNote {
  return {
    id: entry.id,
    // Use canonicalRoute for the URL instead of slug
    slug: entry.canonicalRoute,
    data: {
      title: entry.title || entry.id,
      publishedAt:
        getValidDate(entry.frontmatter.publishedAt) || new Date().toISOString(),
      updatedAt: getValidDate(entry.frontmatter.updatedAt),
      tags: entry.frontmatter.tags || [],
      isPublished: entry.frontmatter.isPublished,
      showToc: entry.frontmatter.showToc ?? true,
      type: entry.frontmatter.type,
    },
    body: entry.body,
  };
}

// Filter by publication status
const filteredEntries = promotedEntries.filter((entry) => {
  // In dev mode, show all promoted notes
  if (isDevEnv) return true;
  // In production, require isPublished: true
  return entry.frontmatter.isPublished === true;
});

// Convert to ObsidianNote format
const allNotes = filteredEntries.map(toObsidianNote);

// Sort by date
const filteredNotes = filterAndSortContent(allNotes);
const sortedNotes = filteredNotes;

// Get all unique tags with counts
const tagCounts = filteredNotes.reduce(
  (acc, note) => {
    if (note.data.tags) {
      note.data.tags.forEach((tag) => {
        acc[tag] = (acc[tag] || 0) + 1;
      });
    }
    return acc;
  },
  {} as Record<string, number>,
);

const sortedTags = Object.entries(tagCounts).sort(([, a], [, b]) => b - a);
---

<!doctype html>
<html lang="en">
  <head>
    <BaseHead
      title="Notes  •  Shovan Chatterjee"
      description={defaultMeta.description}
    />
  </head>
  <RootLayout>
    <NavBreadcrumb section="notes" />

    <main class="flex w-full flex-col gap-6">
      <div class="flex flex-col gap-2">
        <h1 class="text-theme-text font-sans text-4xl font-semibold">Notes</h1>
      </div>

      <!-- Mobile Tags Filter -->
      <MobileTagsFilter
        tags={sortedTags}
        totalCount={filteredNotes.length}
        mode="simple"
        showCloseIcons={true}
      />

      <div class="relative">
        <!-- Notes Section -->
        <div
          class="prose md:prose-xl prose-headings:text-lg md:prose-headings:text-2xl prose-a:decoration-none prose-a:underline-offset-2 flex w-full flex-col md:mt-2"
        >
          <div id="notes-container">
            {
              sortedNotes.length > 0 ? (
                <ul class="not-prose flex flex-col gap-3 pl-0">
                  {sortedNotes.map((note) => (
                    <NoteCard post={note} />
                  ))}
                </ul>
              ) : (
                <p class="text-theme-text-secondary">
                  No notes have been promoted yet. Add{' '}
                  <code>surfaces: ['notes']</code> to your note frontmatter to
                  show them here.
                </p>
              )
            }
          </div>
        </div>

        <!-- Desktop Tags Sidebar -->
        <aside class="absolute top-0 -right-[25%] hidden w-48 md:block">
          <div class="sticky top-8">
            <div class="flex flex-col text-right text-base">
              <button
                class="tag-filter text-theme-text-secondary hover:text-theme-text flex cursor-pointer items-center justify-end gap-1 py-1 outline-none focus:outline-none"
                data-tag="all"
              >
                <span>All</span>
                <span class="text-theme-text-secondary"
                  >{filteredNotes.length}</span
                >
              </button>
              {
                sortedTags.map(([tag, count]) => (
                  <button
                    class="tag-filter text-theme-text-secondary hover:text-theme-text flex cursor-pointer items-center justify-end gap-1 py-1 outline-none focus:outline-none"
                    data-tag={tag}
                  >
                    <span class="">{tag}</span>
                    <span class="text-theme-text-secondary">{count}</span>
                  </button>
                ))
              }
            </div>
          </div>
        </aside>
      </div>
    </main>

    <script>
      // Wait for DOM to be fully loaded
      document.addEventListener('DOMContentLoaded', function () {
        // Tag filtering functionality with URL parameter support
        const tagFilters = document.querySelectorAll('.tag-filter');
        const noteItems = document.querySelectorAll('.note-item');

        // Function to get URL parameter
        function getUrlParam(param: string): string | null {
          const urlParams = new URLSearchParams(window.location.search);
          return urlParams.get(param);
        }

        // Function to set URL parameter
        function setUrlParam(param: string, value: string): void {
          const url = new URL(window.location.href);
          if (value === 'all') {
            url.searchParams.delete(param);
          } else {
            url.searchParams.set(param, value);
          }
          window.history.pushState({}, '', url.toString());
        }

        // Function to apply filter
        function applyFilter(selectedTag: string): void {
          const tag = selectedTag || 'all';

          // Reset all notes to visible first
          noteItems.forEach((item) => {
            if (item && (item as HTMLElement).style) {
              (item as HTMLElement).style.display = 'block';
            }
          });

          // Update active states for all filters
          tagFilters.forEach((f) => {
            if (f.closest('aside')) {
              // Reset desktop styles only
              f.classList.remove('text-theme-text', 'font-bold');
              f.classList.add('text-theme-text-secondary');
            } else {
              // Reset mobile styles only
              f.classList.remove(
                'font-bold',
                'text-theme-text',
                'border-theme-text',
              );
              f.classList.add(
                'font-normal',
                'text-theme-text-secondary',
                'border-theme-border',
              );
            }
          });

          // Find and activate the correct filter
          const activeFilters = Array.from(tagFilters).filter(
            (f) =>
              (f as HTMLElement).dataset &&
              (f as HTMLElement).dataset!.tag === tag,
          );
          activeFilters.forEach((activeFilter) => {
            // Desktop active styles (only for desktop sidebar)
            if (activeFilter.closest('aside')) {
              activeFilter.classList.remove('text-theme-text-secondary');
              activeFilter.classList.add('text-theme-text', 'font-bold');
            }

            // Mobile active styles (only for mobile filter)
            if (!activeFilter.closest('aside')) {
              activeFilter.classList.remove(
                'font-normal',
                'text-theme-text-secondary',
                'border-theme-border',
              );
              activeFilter.classList.add(
                'font-bold',
                'text-theme-text',
                'border-theme-text',
              );
            }
          });

          // Filter notes only if not "all"
          if (tag !== 'all') {
            noteItems.forEach((item) => {
              const noteTags =
                (item as HTMLElement).dataset &&
                (item as HTMLElement).dataset.tags
                  ? (item as HTMLElement).dataset.tags!.split(',')
                  : [];

              if (!noteTags.includes(tag) && (item as HTMLElement).style) {
                (item as HTMLElement).style.display = 'none';
              }
            });
          }
        }

        // Initialize filter based on URL parameter on page load
        const initialTag = getUrlParam('tag');
        applyFilter(initialTag || 'all');

        // Add click event listeners
        tagFilters.forEach((filter) => {
          filter.addEventListener('click', () => {
            const selectedTag =
              (filter as HTMLElement).dataset &&
              (filter as HTMLElement).dataset.tag;
            if (selectedTag) {
              setUrlParam('tag', selectedTag);
              applyFilter(selectedTag);
            }
          });
        });

        // Handle browser back/forward navigation
        window.addEventListener('popstate', () => {
          const tag = getUrlParam('tag');
          applyFilter(tag || 'all');
        });
      });
    </script>
  </RootLayout>
</html>
