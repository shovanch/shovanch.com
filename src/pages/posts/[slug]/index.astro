---
import PostLayout from '~/layouts/post-layout.astro';
import { getReadingTime } from '~/utils/reading-time';
import { generateToc } from '~/utils/toc';
import {
  shouldGenerateStaticPath,
  validateContentAccess,
} from '~/utils/content-operations';

import {
  type CollectionEntry,
  getCollection,
  render,
  getEntry,
} from 'astro:content';
// import { getReadingTime } from '@utils/index';
type Props = CollectionEntry<'posts'>;

export async function getStaticPaths() {
  const allPosts = await getCollection('posts');
  return allPosts.filter(shouldGenerateStaticPath).map((post) => ({
    params: {
      id: post.id,
      slug: post.id,
    },
    props: post,
  }));
}

// 1. Get the slug from the incoming server request
const { id: _id, slug } = Astro.params;

if (slug === undefined) {
  return Astro.redirect('/404');
}

// 2. Query for the entry directly using the request slug
const post = await getEntry('posts', slug);

// 3. Redirect if the entry does not exist
if (post === undefined) {
  return Astro.redirect('/404');
}

// 4. Validate access to this content
try {
  validateContentAccess(post);
} catch {
  return Astro.redirect('/404');
}

// 5. Render the entry to HTML in the template
const { Content, headings } = await render(post);

const readingTimeText = post.data.readingTime
  ? `${post.data.readingTime} min read`
  : post.body
    ? getReadingTime(post.body)
    : undefined;

const tocHeadings = post.data.showToc ? generateToc(headings, 2, 2) : undefined;

// Generate summary from first paragraph of content (for meta description) if not provided
const generateSummary = (body: string | undefined, maxLength = 160): string => {
  if (!body) return '';

  // Remove frontmatter if present
  const contentWithoutFrontmatter = body.replace(/^---[\s\S]*?---\n*/, '');

  // Remove markdown formatting
  const plainText = contentWithoutFrontmatter
    .replace(/^import\s+.+$/gm, '') // Remove import statements
    .replace(/^#+\s+.+$/gm, '') // Remove headings
    .replace(/```[\s\S]*?```/g, '') // Remove code blocks
    .replace(/`[^`]+`/g, '') // Remove inline code
    .replace(/<[^>]+>/g, '') // Remove JSX/HTML tags
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Convert links to text
    .replace(/[*_`~]/g, '') // Remove emphasis markers
    .replace(/^\s*[-*+]\s+/gm, '') // Remove list markers
    .replace(/\n+/g, ' ') // Convert newlines to spaces
    .trim();

  // Get first meaningful sentence(s) up to maxLength
  if (plainText.length <= maxLength) return plainText;

  // Try to cut at sentence boundary
  const truncated = plainText.substring(0, maxLength);
  const lastSentenceEnd = Math.max(
    truncated.lastIndexOf('. '),
    truncated.lastIndexOf('! '),
    truncated.lastIndexOf('? ')
  );

  if (lastSentenceEnd > maxLength * 0.5) {
    return truncated.substring(0, lastSentenceEnd + 1);
  }

  // Fall back to word boundary
  const lastSpace = truncated.lastIndexOf(' ');
  return lastSpace > 0 ? truncated.substring(0, lastSpace) + '...' : truncated + '...';
};

const summary = post.data.summary || generateSummary(post.body);
---

<PostLayout
  {...(({ readingTime: _, summary: __, ...rest }) => rest)(post.data)}
  summary={summary}
  headings={tocHeadings}
  readingTime={readingTimeText}
  slug={slug}
  post={post}
>
  <Content frontmatter={post.data} />
</PostLayout>
